// src/nodes/comment/comment.service.spec.ts - REFACTORED FOR NEW ARCHITECTURE

import { Test, TestingModule } from '@nestjs/testing';
import { CommentService } from './comment.service';
import { CommentSchema } from '../../neo4j/schemas/comment.schema';
import { VisibilityService } from '../../users/visibility/visibility.service';
import {
  HttpException,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import type { CommentData } from '../../neo4j/schemas/comment.schema';
import type { VoteResult, VoteStatus } from '../../neo4j/schemas/vote.schema';

describe('CommentService - Refactored Architecture', () => {
  let service: CommentService;
  let commentSchema: jest.Mocked<CommentSchema>;
  let visibilityService: jest.Mocked<VisibilityService>;

  const mockCommentData: CommentData = {
    id: 'comment-123',
    createdBy: 'user-456',
    discussionId: 'discussion-789',
    commentText: 'Test comment text',
    parentCommentId: undefined,
    createdAt: new Date(),
    updatedAt: new Date(),
    publicCredit: false,
    inclusionPositiveVotes: 0,
    inclusionNegativeVotes: 0,
    inclusionNetVotes: 0,
    contentPositiveVotes: 5,
    contentNegativeVotes: 2,
    contentNetVotes: 3,
  };

  const mockVoteResult: VoteResult = {
    inclusionPositiveVotes: 0,
    inclusionNegativeVotes: 0,
    inclusionNetVotes: 0,
    contentPositiveVotes: 6,
    contentNegativeVotes: 2,
    contentNetVotes: 4,
  };

  const mockVoteStatus: VoteStatus = {
    inclusionStatus: null,
    inclusionPositiveVotes: 0,
    inclusionNegativeVotes: 0,
    inclusionNetVotes: 0,
    contentStatus: 'agree',
    contentPositiveVotes: 6,
    contentNegativeVotes: 2,
    contentNetVotes: 4,
  };

  beforeEach(async () => {
    const mockCommentSchema = {
      // BaseNodeSchema inherited methods
      findById: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      voteContent: jest.fn(),
      getVoteStatus: jest.fn(),
      removeVote: jest.fn(),
      getVotes: jest.fn(),

      // CommentSchema specific methods
      createComment: jest.fn(),
      getCommentsByDiscussionId: jest.fn(),
      getDiscussionCommentStats: jest.fn(),
      getRepliesForComment: jest.fn(),
      canEditComment: jest.fn(),
    };

    const mockVisibilityService = {
      getObjectVisibility: jest.fn(),
      setUserVisibilityPreference: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CommentService,
        {
          provide: CommentSchema,
          useValue: mockCommentSchema,
        },
        {
          provide: VisibilityService,
          useValue: mockVisibilityService,
        },
      ],
    }).compile();

    service = module.get<CommentService>(CommentService);
    commentSchema = module.get(CommentSchema);
    visibilityService = module.get(VisibilityService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  // ============================================
  // CRUD OPERATIONS
  // ============================================

  describe('createComment', () => {
    const validCommentData = {
      createdBy: 'user-456',
      discussionId: 'discussion-789',
      commentText: 'Test comment',
    };

    it('should create a comment successfully with generated UUID', async () => {
      commentSchema.createComment.mockResolvedValue(mockCommentData);

      const result = await service.createComment(validCommentData);

      expect(commentSchema.createComment).toHaveBeenCalledWith(
        expect.objectContaining({
          ...validCommentData,
          id: expect.any(String), // UUID generated by service
        }),
      );
      expect(result).toEqual(mockCommentData);
    });

    it('should throw BadRequestException for missing createdBy', async () => {
      await expect(
        service.createComment({ ...validCommentData, createdBy: '' }),
      ).rejects.toThrow(BadRequestException);

      expect(commentSchema.createComment).not.toHaveBeenCalled();
    });

    it('should throw BadRequestException for missing discussionId', async () => {
      await expect(
        service.createComment({ ...validCommentData, discussionId: '' }),
      ).rejects.toThrow(BadRequestException);

      expect(commentSchema.createComment).not.toHaveBeenCalled();
    });

    it('should throw BadRequestException for empty comment text', async () => {
      await expect(
        service.createComment({ ...validCommentData, commentText: '' }),
      ).rejects.toThrow(BadRequestException);

      expect(commentSchema.createComment).not.toHaveBeenCalled();
    });

    it('should handle schema errors', async () => {
      commentSchema.createComment.mockRejectedValue(
        new Error('Database error'),
      );

      await expect(service.createComment(validCommentData)).rejects.toThrow(
        HttpException,
      );
    });
  });

  describe('getComment', () => {
    it('should get comment by id successfully', async () => {
      commentSchema.findById.mockResolvedValue(mockCommentData);

      const result = await service.getComment('comment-123');

      expect(commentSchema.findById).toHaveBeenCalledWith('comment-123');
      expect(result).toEqual(mockCommentData);
    });

    it('should return null when comment not found', async () => {
      commentSchema.findById.mockResolvedValue(null);

      const result = await service.getComment('nonexistent');

      expect(result).toBeNull();
    });

    it('should throw BadRequestException for empty id', async () => {
      await expect(service.getComment('')).rejects.toThrow(BadRequestException);

      expect(commentSchema.findById).not.toHaveBeenCalled();
    });
  });

  describe('updateComment', () => {
    const updateData = { commentText: 'Updated comment text' };

    it('should update comment successfully after edit permission check', async () => {
      commentSchema.canEditComment.mockResolvedValue(true);
      const updatedComment = { ...mockCommentData, ...updateData };
      commentSchema.update.mockResolvedValue(updatedComment);

      const result = await service.updateComment(
        'comment-123',
        'user-456',
        updateData,
      );

      expect(commentSchema.canEditComment).toHaveBeenCalledWith(
        'comment-123',
        'user-456',
      );
      expect(commentSchema.update).toHaveBeenCalledWith(
        'comment-123',
        updateData,
      );
      expect(result).toEqual(updatedComment);
    });

    it('should throw BadRequestException if user cannot edit', async () => {
      commentSchema.canEditComment.mockResolvedValue(false);

      await expect(
        service.updateComment('comment-123', 'user-456', updateData),
      ).rejects.toThrow(BadRequestException);

      expect(commentSchema.update).not.toHaveBeenCalled();
    });

    it('should throw BadRequestException for empty id', async () => {
      await expect(
        service.updateComment('', 'user-456', updateData),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException for empty userId', async () => {
      await expect(
        service.updateComment('comment-123', '', updateData),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException for empty comment text', async () => {
      await expect(
        service.updateComment('comment-123', 'user-456', { commentText: '' }),
      ).rejects.toThrow(BadRequestException);
    });
  });

  describe('deleteComment', () => {
    it('should delete comment successfully', async () => {
      commentSchema.delete.mockResolvedValue(undefined);

      await service.deleteComment('comment-123');

      expect(commentSchema.delete).toHaveBeenCalledWith('comment-123');
    });

    it('should throw BadRequestException for empty id', async () => {
      await expect(service.deleteComment('')).rejects.toThrow(
        BadRequestException,
      );

      expect(commentSchema.delete).not.toHaveBeenCalled();
    });

    it('should handle schema errors', async () => {
      commentSchema.delete.mockRejectedValue(new Error('Database error'));

      await expect(service.deleteComment('comment-123')).rejects.toThrow(
        HttpException,
      );
    });
  });

  describe('canEditComment', () => {
    it('should check edit permission successfully', async () => {
      commentSchema.canEditComment.mockResolvedValue(true);

      const result = await service.canEditComment('comment-123', 'user-456');

      expect(commentSchema.canEditComment).toHaveBeenCalledWith(
        'comment-123',
        'user-456',
      );
      expect(result).toBe(true);
    });

    it('should return false on errors', async () => {
      commentSchema.canEditComment.mockRejectedValue(
        new Error('Database error'),
      );

      const result = await service.canEditComment('comment-123', 'user-456');

      expect(result).toBe(false);
    });

    it('should throw BadRequestException for empty parameters', async () => {
      await expect(service.canEditComment('', 'user-456')).rejects.toThrow(
        BadRequestException,
      );
      await expect(service.canEditComment('comment-123', '')).rejects.toThrow(
        BadRequestException,
      );
    });
  });

  // ============================================
  // VOTING OPERATIONS
  // ============================================

  describe('voteComment', () => {
    it('should vote on comment content successfully', async () => {
      commentSchema.voteContent.mockResolvedValue(mockVoteResult);

      const result = await service.voteComment(
        'comment-123',
        'user-456',
        true,
        'CONTENT',
      );

      expect(commentSchema.voteContent).toHaveBeenCalledWith(
        'comment-123',
        'user-456',
        true,
      );
      expect(result).toEqual(mockVoteResult);
    });

    it('should throw BadRequestException for non-CONTENT voting', async () => {
      await expect(
        service.voteComment(
          'comment-123',
          'user-456',
          true,
          'INCLUSION' as any,
        ),
      ).rejects.toThrow(BadRequestException);

      expect(commentSchema.voteContent).not.toHaveBeenCalled();
    });

    it('should throw BadRequestException for empty parameters', async () => {
      await expect(
        service.voteComment('', 'user-456', true, 'CONTENT'),
      ).rejects.toThrow(BadRequestException);

      await expect(
        service.voteComment('comment-123', '', true, 'CONTENT'),
      ).rejects.toThrow(BadRequestException);
    });
  });

  describe('getCommentVoteStatus', () => {
    it('should get vote status successfully', async () => {
      commentSchema.getVoteStatus.mockResolvedValue(mockVoteStatus);

      const result = await service.getCommentVoteStatus(
        'comment-123',
        'user-456',
      );

      expect(commentSchema.getVoteStatus).toHaveBeenCalledWith(
        'comment-123',
        'user-456',
      );
      expect(result).toEqual(mockVoteStatus);
    });

    it('should throw BadRequestException for empty parameters', async () => {
      await expect(
        service.getCommentVoteStatus('', 'user-456'),
      ).rejects.toThrow(BadRequestException);

      await expect(
        service.getCommentVoteStatus('comment-123', ''),
      ).rejects.toThrow(BadRequestException);
    });
  });

  describe('removeCommentVote', () => {
    it('should remove vote successfully', async () => {
      commentSchema.removeVote.mockResolvedValue(mockVoteResult);

      const result = await service.removeCommentVote(
        'comment-123',
        'user-456',
        'CONTENT',
      );

      expect(commentSchema.removeVote).toHaveBeenCalledWith(
        'comment-123',
        'user-456',
        'CONTENT',
      );
      expect(result).toEqual(mockVoteResult);
    });

    it('should throw BadRequestException for non-CONTENT voting', async () => {
      await expect(
        service.removeCommentVote(
          'comment-123',
          'user-456',
          'INCLUSION' as any,
        ),
      ).rejects.toThrow(BadRequestException);
    });
  });

  describe('getCommentVotes', () => {
    it('should get vote counts successfully', async () => {
      commentSchema.getVotes.mockResolvedValue(mockVoteResult);

      const result = await service.getCommentVotes('comment-123');

      expect(commentSchema.getVotes).toHaveBeenCalledWith('comment-123');
      expect(result).toEqual(mockVoteResult);
    });

    it('should throw BadRequestException for empty id', async () => {
      await expect(service.getCommentVotes('')).rejects.toThrow(
        BadRequestException,
      );
    });
  });

  // ============================================
  // VISIBILITY OPERATIONS
  // ============================================

  describe('setCommentVisibilityPreference', () => {
    it('should set visibility preference successfully', async () => {
      const mockPreference = {
        isVisible: false,
        source: 'user' as const,
        timestamp: Date.now(),
      };
      visibilityService.setUserVisibilityPreference.mockResolvedValue(
        mockPreference,
      );

      const result = await service.setCommentVisibilityPreference(
        'user-456',
        'comment-123',
        false,
      );

      expect(
        visibilityService.setUserVisibilityPreference,
      ).toHaveBeenCalledWith('user-456', 'comment-123', false);
      expect(result).toEqual(mockPreference);
    });

    it('should throw BadRequestException for empty parameters', async () => {
      await expect(
        service.setCommentVisibilityPreference('', 'comment-123', true),
      ).rejects.toThrow(BadRequestException);

      await expect(
        service.setCommentVisibilityPreference('user-456', '', true),
      ).rejects.toThrow(BadRequestException);
    });
  });

  describe('getCommentVisibilityForUser', () => {
    it('should get visibility status successfully', async () => {
      commentSchema.findById.mockResolvedValue(mockCommentData);
      visibilityService.getObjectVisibility.mockResolvedValue(true);

      const result = await service.getCommentVisibilityForUser(
        'comment-123',
        'user-456',
      );

      expect(commentSchema.findById).toHaveBeenCalledWith('comment-123');
      expect(visibilityService.getObjectVisibility).toHaveBeenCalledWith(
        'user-456',
        'comment-123',
        { netVotes: 3 }, // contentNetVotes from mockCommentData
      );
      expect(result).toBe(true);
    });

    it('should throw NotFoundException if comment not found', async () => {
      commentSchema.findById.mockResolvedValue(null);

      await expect(
        service.getCommentVisibilityForUser('nonexistent', 'user-456'),
      ).rejects.toThrow(NotFoundException);
    });

    it('should work without userId (anonymous)', async () => {
      commentSchema.findById.mockResolvedValue(mockCommentData);
      visibilityService.getObjectVisibility.mockResolvedValue(true);

      const result = await service.getCommentVisibilityForUser('comment-123');

      expect(visibilityService.getObjectVisibility).toHaveBeenCalledWith(
        null,
        'comment-123',
        { netVotes: 3 },
      );
      expect(result).toBe(true);
    });
  });

  describe('getCommentWithVisibility', () => {
    it('should get comment with visibility status', async () => {
      commentSchema.findById.mockResolvedValue(mockCommentData);
      visibilityService.getObjectVisibility.mockResolvedValue(true);

      const result = await service.getCommentWithVisibility(
        'comment-123',
        'user-456',
      );

      expect(result).toEqual({ ...mockCommentData, isVisible: true });
    });

    it('should return null if comment not found', async () => {
      commentSchema.findById.mockResolvedValue(null);

      const result = await service.getCommentWithVisibility('nonexistent');

      expect(result).toBeNull();
    });
  });

  // ============================================
  // DISCUSSION-LEVEL OPERATIONS
  // ============================================

  describe('getCommentsByDiscussionId', () => {
    it('should get comments for discussion', async () => {
      const mockComments = [mockCommentData];
      commentSchema.getCommentsByDiscussionId.mockResolvedValue(mockComments);

      const result = await service.getCommentsByDiscussionId('discussion-789');

      expect(commentSchema.getCommentsByDiscussionId).toHaveBeenCalledWith(
        'discussion-789',
      );
      expect(result).toEqual(mockComments);
    });

    it('should throw BadRequestException for empty discussionId', async () => {
      await expect(service.getCommentsByDiscussionId('')).rejects.toThrow(
        BadRequestException,
      );
    });
  });

  describe('getCommentsByDiscussionIdWithVisibility', () => {
    it('should get comments with visibility and sort by newest', async () => {
      const commentOld = {
        ...mockCommentData,
        id: 'comment-old',
        createdAt: new Date('2023-01-01'),
      };
      const commentNew = {
        ...mockCommentData,
        id: 'comment-new',
        createdAt: new Date('2023-01-02'),
      };
      const mockComments = [commentOld, commentNew];

      commentSchema.getCommentsByDiscussionId.mockResolvedValue(mockComments);

      // Mock findById to return the correct comment for each ID
      commentSchema.findById.mockImplementation((id: string) => {
        if (id === 'comment-old') return Promise.resolve(commentOld);
        if (id === 'comment-new') return Promise.resolve(commentNew);
        return Promise.resolve(null);
      });

      visibilityService.getObjectVisibility.mockResolvedValue(true);

      const result = await service.getCommentsByDiscussionIdWithVisibility(
        'discussion-789',
        'user-456',
        'newest',
      );

      expect(result).toHaveLength(2);
      expect(result[0].id).toBe('comment-new'); // Newest first
      expect(result[0].isVisible).toBe(true);
    });

    it('should sort by oldest', async () => {
      const commentNew = {
        ...mockCommentData,
        id: 'comment-new',
        createdAt: new Date('2023-01-02'),
      };
      const commentOld = {
        ...mockCommentData,
        id: 'comment-old',
        createdAt: new Date('2023-01-01'),
      };
      const mockComments = [commentNew, commentOld];

      commentSchema.getCommentsByDiscussionId.mockResolvedValue(mockComments);

      // Mock findById to return the correct comment for each ID
      commentSchema.findById.mockImplementation((id: string) => {
        if (id === 'comment-new') return Promise.resolve(commentNew);
        if (id === 'comment-old') return Promise.resolve(commentOld);
        return Promise.resolve(null);
      });

      visibilityService.getObjectVisibility.mockResolvedValue(true);

      const result = await service.getCommentsByDiscussionIdWithVisibility(
        'discussion-789',
        'user-456',
        'oldest',
      );

      expect(result[0].id).toBe('comment-old'); // Oldest first
    });

    it('should sort by top voted', async () => {
      const commentLow = {
        ...mockCommentData,
        id: 'comment-low',
        contentNetVotes: 1,
      };
      const commentHigh = {
        ...mockCommentData,
        id: 'comment-high',
        contentNetVotes: 10,
      };
      const mockComments = [commentLow, commentHigh];

      commentSchema.getCommentsByDiscussionId.mockResolvedValue(mockComments);

      // Mock findById to return the correct comment for each ID
      commentSchema.findById.mockImplementation((id: string) => {
        if (id === 'comment-low') return Promise.resolve(commentLow);
        if (id === 'comment-high') return Promise.resolve(commentHigh);
        return Promise.resolve(null);
      });

      visibilityService.getObjectVisibility.mockResolvedValue(true);

      const result = await service.getCommentsByDiscussionIdWithVisibility(
        'discussion-789',
        'user-456',
        'topVoted',
      );

      expect(result[0].id).toBe('comment-high'); // Highest votes first
    });
  });

  describe('getDiscussionCommentStats', () => {
    it('should get comment statistics', async () => {
      const mockStats = {
        totalComments: 15,
        rootComments: 8,
        replies: 7,
        averageContentScore: 2.5,
      };
      commentSchema.getDiscussionCommentStats.mockResolvedValue(mockStats);

      const result = await service.getDiscussionCommentStats('discussion-789');

      expect(commentSchema.getDiscussionCommentStats).toHaveBeenCalledWith(
        'discussion-789',
      );
      expect(result).toEqual(mockStats);
    });

    it('should throw BadRequestException for empty discussion id', async () => {
      await expect(service.getDiscussionCommentStats('')).rejects.toThrow(
        BadRequestException,
      );
    });
  });

  // ============================================
  // THREADED COMMENT OPERATIONS
  // ============================================

  describe('getCommentReplies', () => {
    it('should get comment replies with visibility', async () => {
      const reply1 = {
        ...mockCommentData,
        id: 'reply-1',
        parentCommentId: 'comment-123',
      };
      const reply2 = {
        ...mockCommentData,
        id: 'reply-2',
        parentCommentId: 'comment-123',
      };
      const mockReplies = [reply1, reply2];

      commentSchema.getRepliesForComment.mockResolvedValue(mockReplies);

      // Mock findById to return the correct reply for each ID
      commentSchema.findById.mockImplementation((id: string) => {
        if (id === 'reply-1') return Promise.resolve(reply1);
        if (id === 'reply-2') return Promise.resolve(reply2);
        return Promise.resolve(null);
      });

      visibilityService.getObjectVisibility.mockResolvedValue(true);

      const result = await service.getCommentReplies('comment-123', 'user-456');

      expect(commentSchema.getRepliesForComment).toHaveBeenCalledWith(
        'comment-123',
      );
      expect(result).toHaveLength(2);
      expect(result[0].isVisible).toBe(true);
    });

    it('should throw BadRequestException for empty commentId', async () => {
      await expect(service.getCommentReplies('')).rejects.toThrow(
        BadRequestException,
      );
    });
  });

  describe('getCommentThread', () => {
    it('should get complete comment thread', async () => {
      const reply1 = {
        ...mockCommentData,
        id: 'reply-1',
        parentCommentId: 'comment-123',
      };

      // Mock findById for root comment and reply
      commentSchema.findById.mockImplementation((id: string) => {
        if (id === 'comment-123') return Promise.resolve(mockCommentData);
        if (id === 'reply-1') return Promise.resolve(reply1);
        return Promise.resolve(null);
      });

      visibilityService.getObjectVisibility.mockResolvedValue(true);

      const mockReplies = [reply1];
      commentSchema.getRepliesForComment.mockResolvedValue(mockReplies);

      const result = await service.getCommentThread('comment-123', 'user-456');

      expect(result.rootComment.id).toBe('comment-123');
      expect(result.replies).toHaveLength(1);
      expect(result.totalCount).toBe(2); // root + 1 reply
    });

    it('should throw NotFoundException for nonexistent comment', async () => {
      commentSchema.findById.mockResolvedValue(null);

      await expect(
        service.getCommentThread('nonexistent', 'user-456'),
      ).rejects.toThrow(NotFoundException);
    });

    it('should throw BadRequestException for empty commentId', async () => {
      await expect(service.getCommentThread('')).rejects.toThrow(
        BadRequestException,
      );
    });
  });
});
